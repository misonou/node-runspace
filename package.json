{
    "name": "runspace",
    "version": "1.0.0",
    "description": "Creates a sandbox for running untrusted code.",
    "main": "runspace.js",
    "dependencies": {
        "builtin-modules": "^1.1.0"
    },
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "misonou",
    "license": "MIT",
    "keywords": [
        "sandbox"
    ],
    "repository": {
        "type": "git",
        "url": "https://github.com/misonou/node-runspace.git"
    },
    "bugs": "https://github.com/misonou/node-runspace/issues",
    "readme": "# Runspace\n\nSandbox for running untrusted code with full-fledged module loading mechanism.\n\n## Installation\n\n`npm install runspace`\n\n## Usage\n\n### Runspace(path, [options])\n\nCreates a sandbox rooted at the given path.\n\nFiles and modules outside the given path are normally denied for access.\nAdditional controls to native and user modules can also be defined\nby creating proxies.\n\nSee [Proxy](#proxy) and [Sandbox](#sandbox) section for more details.\n\n```javascript\nvar Runspace = require('runspace');\nvar runspace = new Runspace('./sandbox');\n\n// all legitimate Node.js codes can be run smoothly\n// inside the created sandbox without acknowledging it\nrunspace.run('                                                \\\n    var fs = require(\"fs\");                                   \\\n    var util = require(\"util\");                               \\\n    fs.readFile(\"./my.txt\", function (err, data) {            \\\n        process.stdout.write(util.format(data, +new Date())); \\\n    });                                                       \\\n');\n```\n\n#### Options\n\nBelow is an exhaustive list of options, with the default value shown.\n\n```javascript\n{\n    // list of whitelist paths where modules inside\n    // can be loaded by untrusted codes\n    loadPaths: []\n}\n```\n\n### runspace.run(code, [filename], [globals])\n\nRuns the code in contextified sandbox.\nIf `filename` is given, it determines the working path for resolving module locations.\n\n```javascript\nvar runspace = new Runspace('/parent/sandbox');\n\n// look for:\n// /parent/sandbox/subdir/dependency\n// /parent/sandbox/subdir/dependency.{js,json,node}\n// /parent/sandbox/subdir/dependency/index.{js,json,node}\n// /parent/sandbox/subdir/node_modules/dependency\n// /parent/sandbox/node_modules/dependency\n// but NOT:\n// /parent/node_modules/dependency\n// /node_modules/dependency\n// /other_global_paths/dependency\nrunspace.run('require(\"dependency\")', '/parent/sandbox/subdir/hello-world.js');\n\n// throws exception for invalid path\nrunspace.run('', '/outside-sandbox/example.js');\n```\n\nThis method is identical to calling `runspace.compile()` then `run()`,\nexcept that this method compiles code each time called.\n\n```javascript\n// the following two lines gives identical result\nrunspace.run(code, filename, globals);\nrunspace.compile(code, filename).run(globals);\n```\n\n#### Passing additional globals\n\nOther than built-in JavaScript and Node.js objects (see [Global](#global)),\nadditional global variables can be passed to the compiled script.\n\n```javascript\nrunspace.run('console.log(number)', { number: 1 }); // prints '1'\n```\n\n**Note:** They are actually not real globals but rather local to\nthe function composed by the supplied code.\n\n### runspace.compile(code, [filename])\n\nCompiles the code in contextified sandbox.\nIf `filename` is given, it determines the working path for resolving module locations.\n\n```javascript\nvar script = runspace.compile('console.log(number)');\nscript.run({ number: 1 }); // prints '1'\n```\n\n### runspace.terminate()\n\nA runspace can be terminated by calling `terminate()`.\n\nAll proxies, event listeners and timeouts are cleared.\nThis allows GC to free resources taken up by the sandbox.\nSubsequent async callbacks and attempts to access proxies will throw exception.\n\n### Event: message\n\nTriggered when `process.send()` is called inside sandbox.\n\n### Event: error\n\nTriggered when an exception is thrown and uncaught inside sandbox.\n\n### Event: terminate\n\nTriggered when `runspace.terminate()` is called.\n\n## Proxy\n\nProxies are wrappers on objects that allow protection\nand interception when those objects are accessed by untrusted code.\n\n> **Important:** Due to limitation in ES5, the proxies generated by this\n  library is not intended to be a polyfill solution, with the following limitation:\n  - Properties are converted to get/setters on proxies to provide interception;\n  - Properties and methods on an object are only available on its proxy when they exist during proxy creation.\n    Afterwards new properties and methods cannot be accessed through the proxy.\n\n### Functions and callbacks\n\nFunctions and callbacks are handled such that arguments and return values are\ntranslated from objects to their proxy counterparts and vice versa.\n\n```javascript\n/* host */\nfunction ClassA() {}\nfunction ClassB() {}\nfunction ClassX() {}\nvar objAdded = {};\nvar instA = new ClassA();\n\nrunspace.add(new ClassA());\nrunspace.add(ClassB);\nrunspace.add(objAdded);\n\nvar returnedInstA = script.run({\n    ClassA: ClassA,\n    ClassB: ClassB,\n    ClassX: ClassX,\n    instA: instA,\n    instB: new ClassB(),\n    instX: new ClassX(),\n    objNotAdded: {},\n    func: function (argInstA) {\n        // arguments from sandbox are un-proxied\n        argInstA === instA;\n        // return value will be re-proxied\n        return instA;\n    }\n});\n// returned value from sandbox is un-proxied\nreturnedInstA === instA;\n```\n```javascript\n/* sandbox */\n// the following objects from host are proxied\nClassA, ClassB, instA, instB, objAdded;\nClassA.prototype, Object.getPrototypeOf(instB);\n\n// the following objects from host are NOT proxied\nClassX, instX, objNotAdded;\n\n// proxied instA is un-proxied when passed to func()\n// and returned instA is re-proxied\nvar returnedInstA = func(instA);\nreturnedInstA === instA;\n\n// proxied instA will be un-proxied when returned to host\nreturn instA;\n```\n\n### runspace.getProxy(target)\n\nGets the proxy if the target has been proxied. Otherwise `undefined` is returned.\n\n### runspace.add/proxy/weakProxy(target, [options])\n\nObjects are proxied in two flavors:\n\n-   **Weakly-referenced** proxies are for temporal objects that lived within\n    the life of sandbox. The references being weak allows GC to collect even though the sandbox is active.\n\n\n-   **Strongly-referenced** proxies are for global and shared objects.\n    The references being strong allows `Runspace` to clear resources when terminating.\n\nThe target's prototypes are **implicitly** proxied recursively,\ni.e. all prototype objects and constructors up\nthe prototype chain have also their proxy counterparts.\n\n**Differences on add/proxy/weakProxy: **\n\n<table>\n    <tr>\n        <td></td>\n        <td>`add`</td>\n        <td>`proxy`</td>\n        <td>`weakProxy`</td>\n    </tr>\n    <tr>\n        <td>`target`</td>\n        <td>Strong</td>\n        <td>Weak</td>\n        <td>Weak</td>\n    </tr>\n    <tr>\n        <td>`target.constructor`<br>`target.__proto__`<br>(recursively) </td>\n        <td>Strong</td>\n        <td>Strong</td>\n        <td>Weak</td>\n    </tr>\n</table>\n\n> **Important:** Calling the proxy generating methods for the same target repeatedly\n  returns the same proxy with its flavor (strong-/weak-referenced) unchanged.\n\n#### Options\n\nBelow is an exhaustive list of options. All options are **optional**.\n\n```javascript\n{\n    // when target is [Function]\n    // name to assign for anonymous function\n    name: '',\n\n    // when target is [Function]\n    // accepted values: 'in', 'out', 'ctor'\n    // specify whether the function:\n    // in: accepts arguments from and returns value to sandbox\n    // out: accepts arguments from and returns value to host\n    // ctor: is a constructor (prototype chain is also proxied)\n    // default -\n    //    if function name starts with an Uppercased letter: 'ctor'\n    //    otherwise: 'in'\n    functionType: '',\n\n    // whitelist of properties and methods allowed to access\n    // see notes below\n    allow: [],\n\n    // blacklist of properties and methods allowed to access\n    // see notes below\n    deny: [],\n\n    // list of properties which their values should be freezed; or\n    // true if values of all properties should be freezed\n    freeze: [],\n\n    // called when getting property on a proxy\n    // see 'Interceptors'\n    get: function (name, value, target, undef) { ... },\n\n    // called when setting property on a proxy\n    // see 'Interceptors'\n    set: function (name, value, target, undef) { ... },\n\n    // called when calling method on a proxy\n    // see 'Interceptors'\n    call: function (name, fn, args, target, undef) { ... },\n\n    // called when creating new instance of a proxied class\n    // see 'Interceptors'\n    new: function (name, fn, args, undef) { ... }\n}\n```\n\n**Note:** To blacklist/whitelist constructor \"static\" and \"instance\" members,\nfollow patterns of `MyConstructor.staticMember` and `MyConstructor#instMember`.\n\nIf blacklist and whitelist are supplied at the same time,\nblacklist takes precendence.\n\n### Interceptors\n\nInterceptors enables modifications on supplied arguments and return value.\n\n#### Arguments to interceptors\n\nReferencing argument names of interceptor options shown in above section:\n\n`name`: name of the property or method intercepted\n\n`fn`: intercepted function\n\n`args`: arguments supplied to the intercepted function\n\n`value`: value supplied to the intercepted property/setter\n\n`target`: target object proxied\n\n`undef`: when returned from interceptors, tell the proxy to return `undefined` as the return value instead of\nproceeding. Arbitrary return value can be wrapped by `undef.wrap()`.\n\n```javascript\nundef.wrap(3);                   // 3\nundef.wrap(null);                // null\nundef.wrap(undefined) === undef; // true\n```\n\n#### Example: Modifying arguments\n\n```javascript\n/* host */\nvar target = {\n    add: function (a, b) {\n        return a + b;\n    }\n};\nrunspace.proxy(target, {\n    call: function (name, fn, args) {\n        if (name === 'add') {\n            args[0] = String(args[0]);\n        }\n    }\n});\n```\n```javascript\n/* sandbox */\ntarget.add(1, 2); // '12'\ntarget.add(null, 2); // 'null2'\n```\n\n#### Example: Modifying return value\n\n```javascript\n/* host */\nvar target = {\n    one: 1,\n    two: 2,\n    three: 3,\n    four: undefined,\n    five: 5\n};\nrunspace.proxy(target, {\n    get: function (name, value, target, undef) {\n        switch (name) {\n        case 'one':\n            return value + '';\n        case 'two':\n            return undef;\n        case 'three':\n        case 'four':\n            return undef.wrap(function () {\n                return name === 'three' ? 3 : undefined;\n            }());\n        }\n        // if reached here, tell the proxy to proceed\n        /* return undefined */;\n    }\n});\n```\n```javascript\n/* sandbox */\ntarget.one;   // '1'\ntarget.two;   // undefined (undefined as return value)\ntarget.three; // 3 (undef.wrap returned as-is)\ntarget.four;  // undefined (undef.wrap wrapped undefined)\ntarget.five;  // 5 (proceed to original property/getter)\n```\n\n## Other properties and methods\n\n### runspace.context\n\nThe contextified sandbox which untrusted code runs in. Additional globals\ncan be declared on this object.\n\n### runspace.stdin, runspace.stdout, runspace.stderr\n\nReadable and writable streams piped from/to `process.stdin`, `process.stdout` and `process.stderr`\nthat are available inside sandbox.\n\n### runspace.send(message)\n\nSandboxed code receives the message by `process.on('message')`.\nThe message can be primitive values or JSON objects.\n\n## Sandbox\n\nThe following section describes behaviors of global objects and built-in modules inside sandbox.\n\n### Global\n\nThe global scope and the `global` object is a contextified sandbox.\n\nOther than standard built-in global objects, objects that are native from Node.js\nare also available inside sandbox. Native objects, typed arrays and buffers are **NOT** proxied.\n\n### EventEmitter\n\nEven if the `EventEmitter` object is shared across sandboxes, listeners are scoped\nwithin each sandbox. That is, only listeners attached from the same sandbox\ncan be listed.\n\n```javascript\nvar ee = new EventEmitter();\nvar rs1 = new Runspace('./');\nvar rs2 = new Runspace('./');\nvar script1 = rs1.compile('ee.on(\"event\", function () {}); console.log(ee.listenerCount(\"event\"))');\nvar script2 = rs2.compile('ee.on(\"event\", function () {}); console.log(ee.listenerCount(\"event\"))');\n\nscript1.run({ ee: ee }); // prints 1\nscript2.run({ ee: ee }); // prints 1\nscript1.run({ ee: ee }); // prints 2\n```\n\n#### EventEmitter.listeners(eventType)\n\nReturns listeners attached by the calling sandbox.\n\n#### EventEmitter.listenerCount(eventType)\n\nReturns the number of listeners attached by the calling sandbox.\n\n#### EventEmitter.removeAllListeners([eventType])\n\nRemoves listeners attached by the calling sandbox.\n\n### process\n\nThe following properties and methods are blocked from access:\n\n`abort`, `binding`, `chdir`, `dlopen`, `exit`, `setgid`, `setegid`, `setuid`, `seteuid`,\n`setgroups`, `initgroups`, `kill`, `disconnect`, `mainModule`.\n\n#### process.stdin, process.stdout, process.stderr\n\nThe three standard IO streams are piped from/to the hosting `runspace.stdin`,\n`runspace.stdout` and `runspace.stderr` writables and readables.\n\nIf there are no `data` event listeners attached in the readable end of those pipes,\nany data written to those streams are discarded.\n\n#### process.cwd()\n\nReturns the sandbox root path rather than actual working directory.\n\n#### process.send(message)\n\nThe message is routed to `runspace.on('message')` instead of that\nthe listening process on IPC channel.\n\n#### process.on('message')\n\nReceives message sent from `runspace.send()` instead of from\nthe listening process on IPC channel.\n\n#### process.on('exit')\n\nThe `exit` event is also triggered when the parent `Runspace` object is terminated.\n\n### timers\n\nHandle returned by `setTimeout` and `setInterval` is `unref`'d and cannot be `ref`'d again.\nCalling `ref()` throws exception.\n\n### fs\n\nAll functions that mention a path other than file descriptor throws exception when\nsupplied with paths outside the sandbox's scope.\n\n### path\n\n`path.resolve()` resolves paths from the sandbox root rather than actual working directory.\n\n### require\n\nModules are resolved and required as-is, except:\n\n-   Built-in modules are proxied\n-   Built-in modules and their exposed APIs can be denied\n-   Modules outside sandbox's root path are invisible unless explicitly allowed\n-   Modules are **NOT** shared across sandboxes, i.e. same module required by\n    different sandboxes are not of the same instance\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2015 misonou\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
}
